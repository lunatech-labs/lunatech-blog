= Mastering Angular Dependency Injection
:author: jakeortega
:revdate: v2, 2025-11-03
:title: Mastering Angular Dependency Injection
:lang: en
:keywords: angular dependency injection, inject function, providers, EnvironmentProviders, standalone
:tags: [Intermediate, dependency injection, providers, services, tokens]
:description: Deep dive into Angular DI in standalone apps: injector hierarchy, scoping strategy, EnvironmentProviders, functional APIs, inject(), tokens, testing, and performance.

Angular’s dependency injection (DI) builds a graph of dependencies so components, directives, and services focus on intent instead of manual wiring. Mastering *where* an instance lives and *how* resolution walks the injector tree lets you design predictable, testable, memory‑efficient applications.

=== Injector Hierarchy (Mental Model)
Resolution walks upward until it finds a matching provider:

1. Platform injector (shared if multiple Angular apps co‑exist).
2. Root injector (global singletons; application bootstrap).
3. Environment injectors (bootstrap, lazy route boundaries, feature provider bundles).
4. Component (element) injectors (per component instance).

First match wins; deeper overrides shadow outer instances.

=== Ways to Register Providers
Angular 20+ (standalone-first) gives four main avenues:

. `@Injectable({ providedIn: ... })` – tree-shakable scoped registration.
. Application bootstrap (`bootstrapApplication(...)`).
. Route configuration (`providers` on route records).
. Component `providers` or `viewProviders`.

Pick the *narrowest* scope that still satisfies reuse. Narrow scope = less lifetime + less accidental coupling.

==== providedIn Options
[source,typescript]
----
import { Injectable, inject } from '@angular/core';
import { HttpClient } from '@angular/common/http';

@Injectable({ providedIn: 'root' })
export class ApiClient {
  private readonly http = inject(HttpClient);

  get<T>(url: string) {
    return this.http.get<T>(url);
  }

  post<T>(url: string, body: unknown) {
    return this.http.post<T>(url, body);
  }
}
----
- root: One instance for the app; tree-shakable if unused.
- platform: Shared across co-hosted Angular apps (rare; e.g. shared analytics).
- any: New instance per *environment injector boundary* (each lazy / route boundary). Useful for per-feature caches, avoid for true globals.
- (no providedIn): Register manually (only when dynamic / conditional).

==== Bootstrap-Level Environment Providers
Use environment providers for cross-cutting concerns (HTTP, routing, theming bundles, global interceptors).
[source,typescript]
----
import { bootstrapApplication } from '@angular/platform-browser';
import { provideRouter, Routes, CanActivateFn, Router } from '@angular/router';
import { provideHttpClient, withInterceptors, HttpInterceptorFn } from '@angular/common/http';
import { Component, inject } from '@angular/core';

@Injectable({ providedIn: 'root' })
class AuthService {
  private tokenValue: string | null = null;
  isLoggedIn() { return !!this.tokenValue; }
  token() { return this.tokenValue; }
}

@Injectable({ providedIn: 'root' })
class AuditService {
  audit(evt: string) { console.log('[audit]', evt); }
}

// Functional guard
const authGuard: CanActivateFn = () => {
  const auth = inject(AuthService);
  const router = inject(Router);
  return auth.isLoggedIn() ? true : router.parseUrl('/login');
};

// Functional interceptor
const authInterceptor: HttpInterceptorFn = (req, next) => {
  const auth = inject(AuthService);
  const token = auth.token();
  return token
    ? next(req.clone({ setHeaders: { Authorization: `Bearer ${token}` } }))
    : next(req);
};

const routes: Routes = [
  {
    path: '',
    loadComponent: () => import('./home.component').then(m => m.HomeComponent),
  },
  {
    path: 'dashboard',
    canActivate: [authGuard],
    loadComponent: () => import('./dashboard.component').then(m => m.DashboardComponent),
  },
];

@Component({
  selector: 'app-root',
  standalone: true,
  template: `<router-outlet />`,
})
class AppComponent {}

bootstrapApplication(AppComponent, {
  providers: [
    provideHttpClient(withInterceptors([authInterceptor])),
    provideRouter(routes),
  ],
});
----
`withInterceptors()` returns EnvironmentProviders, enabling composable bundles without manual multi arrays.

==== Route-Scoped Providers
Created on navigation in, destroyed on navigation out.
[source,typescript]
----
import { Routes } from '@angular/router';
import { EnvironmentProviders, makeEnvironmentProviders } from '@angular/core';

class AdminApiClient extends ApiClient {}

export function provideAdminApi(): EnvironmentProviders {
  return makeEnvironmentProviders([
    { provide: ApiClient, useClass: AdminApiClient },
  ]);
}

export const routes: Routes = [
  {
    path: 'admin',
    providers: [provideAdminApi()],
    loadComponent: () => import('./admin/admin.component').then(m => m.AdminComponent),
  },
];
----

==== Component-Scoped Providers
Per component instance; ideal for local, ephemeral state.
[source,typescript]
----
import { Component, inject, Injectable, DestroyRef, OnInit } from '@angular/core';
import { JsonPipe } from '@angular/common';
import { takeUntilDestroyed } from '@angular/core/rxjs-interop';

@Injectable()
class UserService {
  stream() { 
  	/* return Observable<User[]> */ 
    return inject(ApiClient).get<User[]>('/users'); 
  }
}

@Component({
  selector: 'user-panel',
  template: `
    <h3>User Panel</h3>
    <pre>{{ users | json }}</pre>
  `,
  imports: [JsonPipe],
  providers: [UserService],
  standalone: true,
})
class UserPanelComponent implements OnInit {
  private readonly usersSvc = inject(UserService);
  private readonly destroyRef = inject(DestroyRef);
  users: unknown;

  ngOnInit() {
    this.usersSvc.stream()
      .pipe(takeUntilDestroyed(this.destroyRef))
      .subscribe(data => this.users = data);
  }
}
----

==== Multi Providers & Tokens
Aggregate implementations under one token.
[source,typescript]
----
import { InjectionToken, Inject, Injectable } from '@angular/core';

export interface Logger { log(message: string): void; }
export const LOGGER = new InjectionToken<Logger[]>('LOGGER');

@Injectable({ providedIn: 'root' })
class ConsoleLogger implements Logger {
  log(msg: string) { console.log('[console]', msg); }
}

@Injectable({ providedIn: 'root' })
class RemoteLogger implements Logger {
  log(msg: string) { /* send to backend */ }
}

export const provideLoggers = () => ([
  { provide: LOGGER, useClass: ConsoleLogger, multi: true },
  { provide: LOGGER, useClass: RemoteLogger, multi: true },
]);

@Injectable({ providedIn: 'root' })
class AuditService {
  constructor(@Inject(LOGGER) private readonly loggers: Logger[]) {}
  audit(evt: string) { this.loggers.forEach(l => l.log(evt)); }
}
----

=== Scoping Strategy & Guidelines
- Root: configuration tokens, API clients, auth/session, global caches.
- Route: feature facades, feature-local caches, conditional backends.
- Component: ephemeral UI coordination, short-lived request batching.

Prefer named factory helpers (e.g. `provideAdminApi()`) for intentional overrides. This makes overrides explicit and reduces accidental shadowing.



===== providers vs viewProviders:

- providers: visible to component + projected content.
- viewProviders: hidden from projected content (isolates internal implementations).
[source,typescript]
----
import { Component, InjectionToken } from '@angular/core';

export const THEME = new InjectionToken<string>('THEME');

@Component({
  selector: 'card',
  template: `
  	<section class="card">
  	  <ng-content />
    </section>
  `,
  viewProviders: [{ provide: THEME, useValue: 'dark' }],
  standalone: true,
})
class CardComponent {}
----

=== The inject() Function & Functional APIs
Removes constructor boilerplate; usable in guards, interceptors, resolvers, and field initializers.
[source,typescript]
----
import { inject, InjectionToken } from '@angular/core';

export interface AppConfig {
  apiBase: string;
  enableDebug: boolean;
}

export const APP_CONFIG = new InjectionToken<AppConfig>('APP_CONFIG', {
  providedIn: 'root',
  factory: () => ({ apiBase: '/api', enableDebug: false }),
});

export function buildResourceUrl(path: string): string {
  const cfg = inject(APP_CONFIG, { optional: true });
  const base = cfg?.apiBase ?? '/api';
  return `${base}/${path}`;
}
----
Options:

- optional: true – returns undefined if missing.
- self: true – restrict lookup to current injector (useful for enforced local overrides).

Functional example with teardown:
[source,typescript]
----
import { CanActivateFn, Router } from '@angular/router';
import { HttpInterceptorFn } from '@angular/common/http';
import { inject } from '@angular/core';
import { finalize } from 'rxjs';

const authGuard: CanActivateFn = () => {
  const auth = inject(AuthService);
  const router = inject(Router);
  return auth.isLoggedIn() ? true : router.parseUrl('/login');
};

const timingInterceptor: HttpInterceptorFn = (req, next) => {
  const audit = inject(AuditService);
  const start = performance.now();
  return next(req).pipe(
    finalize(() =>
      audit.audit(`HTTP ${req.method} ${req.url} in ${performance.now() - start}ms`)
    )
  );
};
----

=== Signals + Teardown
Signals integrate cleanly; use `takeUntilDestroyed` for Observable bridges.
[source,typescript]
----
import { Component, inject, signal, OnInit } from '@angular/core';
import { takeUntilDestroyed } from '@angular/core/rxjs-interop';

@Injectable({ providedIn: 'root' })
class UserService {
  stream() { 
    /* Observable<{ name: string }[]> */ 
    return inject(ApiClient).get<{ name: string }[]>('/users'); 
  }
}

@Component({
  selector: 'user-list',
  template: `
    @for (u of users(); track u) {
      <li>{{ u.name }}</li>
    }
  `,
  standalone: true,
})
class UserListComponent implements OnInit {
  private readonly usersSvc = inject(UserService);
  readonly users = signal<{ name: string }[]>([]);

  ngOnInit() {
    this.usersSvc.stream()
      .pipe(takeUntilDestroyed())
      .subscribe(data => this.users.set(data));
  }
}
----

=== Factory Providers with inject()
Bundle related dependencies explicitly.
[source,typescript]
----
import { EnvironmentProviders, inject, makeEnvironmentProviders } from '@angular/core';

class FeatureClient {
  constructor(
    private readonly api: ApiClient, 
    private readonly cfg: AppConfig
  ) {}
}

export function provideFeature(): EnvironmentProviders {
  return makeEnvironmentProviders([
    {
      provide: FeatureClient,
      useFactory: () => {
        const api = inject(ApiClient);
        const cfg = inject(APP_CONFIG);
        return new FeatureClient(api, cfg);
      },
    },
  ]);
}
----

=== Configuration via InjectionToken
Small, composable tokens > monolithic config objects.
[source,typescript]
----
import { InjectionToken } from '@angular/core';

export interface Clock { now(): number; }

export const CLOCK = new InjectionToken<Clock>('CLOCK', {
  providedIn: 'root',
  factory: (): Clock => ({ now: () => Date.now() }),
});
----
// Test override example:
// TestBed.overrideProvider(CLOCK, { useValue: { now: () => 123 } });

=== Testing & Swapping Implementations
- Override narrow scopes for focused tests.
- Use tokens for browser APIs (Date, storage) to avoid globals.
- Prefer useExisting when layering behavior (preserves singleton identity).
[source,typescript]
----
import { TestBed } from '@angular/core/testing';
import { Injectable } from '@angular/core';

class MockApiClient extends ApiClient {
  override get<T>(url: string) { return super.get<T>('mock-' + url); }
}

TestBed.configureTestingModule({
  providers: [
    { provide: ApiClient, useClass: MockApiClient },
  ],
});

TestBed.overrideProvider(APP_CONFIG, { 
  useValue: { apiBase: '/mock', enableDebug: true } 
});

const client = TestBed.inject(ApiClient);
----

=== Performance & Pitfalls
Performance tips:

- Root singletons + tree-shaking keep bundles lean.
- Route-scoped providers free memory after navigation.
- Avoid heavy services in large repeated lists (each instance multiplies cost).
- Wrap override sets (`provideAdminApi`) to document intent.
- Use optional sparingly; frequent silent fallbacks can hide design issues.
- Combine self with tokens where a local override must not leak to ancestors.

Common pitfalls:

- Accidental duplication with providedIn: 'any' when a true singleton was intended.
- Component-level providers in high-frequency structural contexts (e.g. inside *ngFor) cause churn.
- Unlabeled overrides make debugging “works here, breaks there” harder.
- Overly large configuration objects coupling unrelated concerns.

=== Quick Scoping Cheat Sheet

- One shared cache / config: root.
- Different instance per lazy feature: route provider or providedIn: 'any'.
- Per component ephemeral state: component provider.
- Intentional isolation across lazy boundaries: providedIn: 'any' (document rationale).

=== Conclusion
Explicit provider scope produces clarity and predictable lifecycles. Think in boundaries:

- Root for infrastructure.
- Routes for feature lifespan.
- Components for per-instance UI state.

Use inject() to cut boilerplate, tokens for decoupling, EnvironmentProviders for composition. Intentional scoping and documented overrides pay long-term dividends.

=== Next Steps

- Convert a class-based guard to a functional guard with inject().
- Introduce a configuration token and override it in a test.
- Audit component providers; promote widely reused ones upward.
- Refactor a global cache into a route-scoped instance.
- Explore EnvironmentInjector.runInContext for background tasks requiring DI.
