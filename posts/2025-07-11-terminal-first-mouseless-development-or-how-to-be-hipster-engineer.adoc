= Terminal-first Mouseless Development Or How To A Be Hipster Engineer
vitos-exe
v1.0, 2025-07-11
:title: Terminal-first Mouseless Development Or How To Be Hipster Engineer
:imagesdir: ../media/2025-07-11-terminal-first-mouseless-development-or-how-to-be-hipster-engineer
:lang: en
:tags: [beyond-the-code, bash-to-the-feature, vim, tmux, cli, terminal, en]

In this article I’m trying to give you a slightly different view on
something you do on a daily basis. A philosophy that encourages you to
only use what you really need, keeps you away from being distracted,
lets you think about what your problem really involves and trust what
your fingers have learned instead of relying on visual representation.
That is what I call terminal-first mouseless development. I’ll
try to sell it to you by giving an overview of how you can benefit from it in
the real life. Apart from purely theoretical things, 
we are also going to see real applications of these approaches.
In particular, "`tmux`" and "`neovim`" — industry standards for becoming the real
hipster developer.

== Hipster development?

We are all familiar with our IDEs, coupled with other tools for
tasks like database management (DBeaver), testing API (Postman),
container management (Docker Desktop). Even though they provide
extensive GUI, they are also quite rich in distracting elements.
Additionally, using multiple tools and navigating between them
means a lot of context switching as well as having quite a loaded
environment. If you say that your favorite IDE has everything
built-in, then it violates the philosophy of Unix, which says that it is
more idiomatic to use small tools that do one thing well rather than the
opposite. Sort of single responsibility principle.

And here comes what I call "`**Terminal-first development**`" but can be
called any other similar terms. Its core principle is that your terminal
should be your central hub for development tasks. 
Instead of installing a new GUI application to solve a problem, the terminal-first
approach challenges you to:

* Decompose the problem into smaller, distinct steps.
* Assign a small, dedicated CLI tool to each step.
* Combine these tools, piping their outputs together, to solve the initial challenge.

image::crazy-terminal.gif[]

Practical example: you want to select arbitrary table from your
database, get all of the data within it and pretty-print it as JSON.
You have two options:

[arabic]
. Install and use couple hundred megabytes "`pgAdmin`" that
will create another distractive window in your workflow and eat your
memory, blasting your brain with all the buttons and menus around its
GUI.
. Create a simple script that uses "`psql`" to get list of all
tables in your database, pass them to "`fzf`" so you could interactively
select them, pass table name again to "`psql`" to output data from it in
JSON and finally pass it to "`jq`" to pretty print the result.

Even though I have already intentionally hated on option 1, there could
be a point like: "`Why would I do everything said in the point 2 if I
can just go to pgAdmin and press single button or two?`". And that is
valid. And here we come to one of the most important points here:
approach described in option 2 is just an example of philosophy that you
can follow or *not*. And that is your choice. And it would not be
incorrect or make you bad developer. It is all about what you prefer
(and how lazy you are :P). But if you selected option 2, then you
probably prioritize:

[arabic]
. Modularity & Portability
. Better resource usage
. Minimalistic & distraction-free workflow
. Scriptability & Automation
. Customisation

Another interesting thing to think about the second approach is that if
you look closely, what it is all about is piping, or basically passing
data from one function to another. And with this approach it gives you a
grounded look on something fundamental regarding software engineering in
general — it is quite a lot if not completely about viewing,
manipulating and creating data. Actually pretty much what our brains do.

Last but not least — such approach really encourages learning,
deeper understanding and mastering of general software engineering
skills which eventually raises the level of craftsmanship. Personally, 
this philosophy is what sparks joy in my every day work.

Another philosophy that usually goes hand in hand with terminal-first
one is mouseless or keyboard-centric development, which literally means
what it says — it encourages you to prioritize the usage of keyboard
over a mouse or trackpad for writing or navigating through your code.
Important to say here is that it doesn’t mean that you should never use
those. Sometimes it is quite inefficient to avoid using your trackpad,
but for the most cases the theory is that mostly using your keyboard
makes your development faster, more efficient and less tiring.

image::monkey-smashing-mouse.gif[]

Why? Well, you keep your hands on the keyboard and avoid switching
between it and a mouse. Additionally you rely on muscle memory in the
form of keybindings and not on visual navigation to perform actions.
This way you reduce mental overhead, stay in the flow state and perform basic
actions much faster. For example,
https://blog.superhuman.com/keyboard-vs-mouse/?utm_source=chatgpt.com[the
research by the SuperHuman] showed, that some basic operations that we
perform every day can be done from 2 to 5 seconds faster if performed
with keyboard rather than mouse. And we perform those actions a lot, so
think about amount of time you could save in a day.

But let's not idealise things and talk about downsides. The primary one is the steep learning curve. 
From my experience, following those philosophies really makes you
rethink the way you approach software development. I struggle to point
out the exact points, but it just feels quite different and you really
need time to get used to that new reality and that basically means a
long learning curve. Like the basic parts of it are memorizing all the
keybinds or switching mindset to use CLIs or graphical applications. But
hey, learning all the buttons in your IDE also took time, so it is more
about whether you are ready to commit to that.

== Core In Practice

So now let’s finally go from something totally metaphorical to something
more practical. There isn't  single right way to implement philosophy that
I described higher. But, while finding my own way there, I could
distinguish two core elements or, in fact, pieces of software, that will
help you to build up foundation.

=== tmux

I mentioned, that with terminal-first development your terminal
becomes the "`central hub`" for solving software enginnering tasks. 
When you think about hub you probably expect it providing infrastructure 
that you can utilize to effectively achieve your goals.
The industry standard for that is called "`tmux`",
which is terminal multiplexer by its definition.

It allows you to conveniently create terminal windows, splits or even
sessions for grouping. That makes it easy to organise your work between
multiple projects, for example, and allow you to navigate more smoothly.

You can say yeah, but my terminal emulator can do the same. Sure, but
what if the keybinds change? What if you switch to another emulator? What if
now you have to use a different system? You basically need to adapt and
configure this new tool for yourself. So how using "`tmux`" helps you? 
It is completely platform and terminal-emulator agnostic. Everything you have
to do is to put your configuration file in the root folder and run "`tmux`".
This way you are completely independent of the platform that you run "`tmux`" on top of.

image::tmux.png[]

Another thing is that, at its core, "`tmux`" is a server, having all
your terminal sessions working in background. So this can at least save
you from accidentally pressing Command + Q in your terminal and crashing
out again, but also what you can do is to basically have your whole
terminal session setup running, that you can SSH from any other machine
and have it all there, as "`tmux`" itself is just a command line tool.
Combining configuration basis and server nature you basically become
independent of a machine and/or terminal emulation tools, if you have
your "`tmux`" server hosted somewhere.

Regarding the config, you can do quite a lot, starting from setting basic keybinds, 
finishing with writing custom scripts for your workflow or modifying UI. 
There is even a whole ecosystemof plugins!

And if we talk about downsides, there are not that many actually, except
the steep learning curve, but trust me, the outcome is worth it.

=== neovim

I think most of you know "`vi`" — the editor that's impossible to exit. One of the
first text editors in existence, which relies on the keyboard only. 
This is because there was no mouse in early computers day. Theoretically, you can use
it to perform any tasks related to text editing and code writing. But
the problem with the original "`vi`" is that it is as plain as possible
and when it comes to modern development, not really efficient. Like for
example not having ability to autocomplete code or quickly navigate to
class definition doesn’t sound like a lot of productivity.

To solve this issue "`vim`" was created — a feature rich version of
original "`vi`" with things like syntax highlighting, ability to split
windows, etc. And most importantly — it provides ability for extensive
configuration even featuring its own language — "`vimscript`". That
basically created the possibility to write plugins, that allow you to
customize your experience in vim however you want. As the result,
"`vim`" plugin ecosystem is probably one of the biggest plugin
ecosystems in the world.

But this was not enough for people that considered themselves as ultra
hipsters. This led to creation of Neovim - a fork, partly rewritten in lua.
This way significant gains were achieved in terms of extensibility and architecture.
Nowadays, Neovim is known for its great documentation and is supported by quite big and active community of contributors.

Ultimately, you can think of "`*vim`" as of a constructor. 
Its ecosystem provides you with the bricks you can use to build development
tool to satisfy any needs of yours. From the most plain text editor to
ultra-feature-rich IDE. Basically, you can completely replace whatever you are using now.
Just watch out so as not to violate Unix philosophy.

So how does switching to "`neovim`" feel and what it brings to your
life? First of all, text editing starts to feel so much smoother and the
whole navigation process around the code feels really fluent. Using
"`*vim`" really proves benefits of trusting your muscle memory via
keybinds instead of visual navigating. The overall overhead goes down
and you can also feel it when you have to work with several 
projects/directories. Opening a project, quickly looking for something
and editing it feels so light and easy. Using "`vim`" is like dropping
a huge backpack when going uphill and changing it for something small,
compact, accessible but extendable at the same time. And last but not
least, making the editor behave literally however way you want it to in
a programmatic way is another amazing part.

image::nvim.png[]

But let’s not forget about the struggles you may face: "`vim`" really makes
you rethink the way you write your code (and using keybinds is not the
only part), which will take quite some time. Another thing is
configuring the thing to meet your needs. Yeah, that takes time.
Initially it took me maybe like 20+ hours and it is also non-stop
process but that is fair trade-off for the extensibility you get. There
is a joke in the vim community about people spending more time on customizing
their "`vim`" config than on actually using it. And another thing is
that as it is community driven, you may face things that don’t work
properly. For example, in order to have all the IDE features for java,
you need to run Eclipse’s "`jdtls`", a language server,
which doesn't usually perform well on large Java codebase. 
But your mileage may vary.

== Conclusions

My main point in this article was to provide you with a new perspective.
The approach that you can incorporate in your day-to-day tasks.
Philosophy that embraces you to:

* Think more about what your task involves and what your really need to solve it
* Maintain your workspace clean and distraction-free
* Build unique environment that you love working in
* Introduce joy and creativity in your routine

And while it might feel like a step back, this philosophy is surprisingly forward-thinking. 
Many of today's brand-new AI tools are designed specifically for the command line.
In the end, there is no single way to do things.
Technical benefits like efficiency are important, but so is finding joy and pride in your craft. 
Hipster engineering is something that makes me a better professional and makes me love what I do.
My sincere hope is that you find your own way to do the same.
Thanks for your reading.

image::dancing-puppy.gif[]

